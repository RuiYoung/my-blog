import{_ as t,o as e,c as a,Q as o}from"./chunks/framework.544e8ca7.js";const M=JSON.parse('{"title":"DOM 优化原理与基本实践","description":"","frontmatter":{"title":"DOM 优化原理与基本实践","subtitle":"从DOM中着手性能优化","date":"2019-12-22T00:00:00.000Z","author":"Ruiyoung","tag":["前端性能优化","浏览器"]},"headers":[],"relativePath":"FrontendPerformanceOptimization/2019-12-22-DOM 优化原理与基本实践.md","lastUpdated":null}'),r={name:"FrontendPerformanceOptimization/2019-12-22-DOM 优化原理与基本实践.md"},n=o('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><blockquote><p>DOM 为什么这么慢<br> JS 引擎和渲染引擎（浏览器内核）是独立实现的。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”。过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。</p></blockquote><h3 id="对-dom-的修改引发样式的更迭" tabindex="-1">对 DOM 的修改引发样式的更迭 <a class="header-anchor" href="#对-dom-的修改引发样式的更迭" aria-label="Permalink to &quot;对 DOM 的修改引发样式的更迭&quot;">​</a></h3><p>很多时候，我们对 DOM 的操作都不会局限于访问，而是为了修改它。当我们对 DOM 的修改会引发它外观（样式）上的改变时，就会触发回流或重绘</p><p>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</p><p>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘</p><p><strong>重绘不一定导致回流，回流一定会导致重绘。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。</strong><br><strong>考虑 JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。节省不必要的渲染</strong></p>',7),_=[n];function s(i,c,d,p,l,O){return e(),a("div",null,_)}const h=t(r,[["render",s]]);export{M as __pageData,h as default};
