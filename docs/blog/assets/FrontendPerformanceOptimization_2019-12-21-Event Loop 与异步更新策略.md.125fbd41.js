import{_ as e,o as t,c as o,Q as a}from"./chunks/framework.544e8ca7.js";const h=JSON.parse('{"title":"Event Loop 与异步更新策略","description":"从Event Loop中着手性能优化","frontmatter":{"title":"Event Loop 与异步更新策略","description":"从Event Loop中着手性能优化","date":"2019-12-22T00:00:00.000Z","author":"Ruiyoung","tag":["前端性能优化","浏览器"]},"headers":[],"relativePath":"FrontendPerformanceOptimization/2019-12-21-Event Loop 与异步更新策略.md","lastUpdated":null}'),r={name:"FrontendPerformanceOptimization/2019-12-21-Event Loop 与异步更新策略.md"},n=a('<blockquote><p>Micro-Task 与 Macro-Task</p><blockquote><p>事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。<br> 常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。<br> 常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。</p></blockquote></blockquote><h3 id="每一次循环都是一个这样的过程" tabindex="-1">每一次循环都是一个这样的过程： <a class="header-anchor" href="#每一次循环都是一个这样的过程" aria-label="Permalink to &quot;每一次循环都是一个这样的过程：&quot;">​</a></h3><p>将一个 macro-task 执行并出队 =》将一队 micro-task 执行并出队 =》 执行渲染操作，更新界面=》处理 worker 相关的任务</p><h3 id="渲染的时机" tabindex="-1">渲染的时机 <a class="header-anchor" href="#渲染的时机" aria-label="Permalink to &quot;渲染的时机&quot;">​</a></h3><p>我们更新 DOM 的时间点，应该尽可能靠近渲染的时机。当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择。</p><h3 id="异步更新策略" tabindex="-1">异步更新策略 <a class="header-anchor" href="#异步更新策略" aria-label="Permalink to &quot;异步更新策略&quot;">​</a></h3><p>当我们使用 Vue 或 React 提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。待到适当的时机，队列中的更新任务会被批量触发。这就是异步更新。</p>',7),c=[n];function i(s,_,p,l,d,m){return t(),o("div",null,c)}const k=e(r,[["render",i]]);export{h as __pageData,k as default};
