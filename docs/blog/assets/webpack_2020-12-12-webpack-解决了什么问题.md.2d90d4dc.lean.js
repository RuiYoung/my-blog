import{_ as e,o as t,c,G as n,C as l,a as o,Q as p,A as s,H as r}from"./chunks/framework.544e8ca7.js";const M=JSON.parse('{"title":"webpack 究竟解决了什么问题?","description":"","frontmatter":{"title":"webpack 究竟解决了什么问题?","date":"2020-12-12T00:00:00.000Z","author":"Ruiyoung","tag":["webpack"]},"headers":[],"relativePath":"webpack/2020-12-12-webpack-解决了什么问题.md","lastUpdated":null}'),F={name:"webpack/2020-12-12-webpack-解决了什么问题.md"},D=p("",10),y=s("ul",null,[s("li",null,"模块直接在全局工作，大量模块成员污染全局作用域；"),s("li",null,"没有私有空间，所有模块内的成员都可以在模块外部被访问或者修改；"),s("li",null,"一旦模块增多，容易产生命名冲突；"),s("li",null,"无法管理模块与模块之间的依赖关系；"),s("li",null,"在维护的过程中也很难分辨每个成员所属的模块。")],-1),i=p("",5),A=p("",4),C=p("",24),d=s("ul",null,[s("li",null,"在 Node.js 环境中，我们遵循 CommonJS 规范来组织模块。"),s("li",null,"在浏览器环境中，我们遵循 ES Modules 规范。")],-1),u=p("",9),h=s("ul",null,[s("li",null,"首先，我们所使用的 ES Modules 模块系统本身就存在环境兼容问题。尽管现如今主流浏览器的最新版本都支持这一特性，但是目前还无法保证用户的浏览器使用情况。所以我们还需要解决兼容问题。"),s("li",null,"其次，模块化的方式划分出来的模块文件过多，而前端应用又运行在浏览器中，每一个文件都需要单独从服务器请求回来。零散的模块文件必然会导致浏览器的频繁发送网络请求，影响应用的工作效率。"),s("li",null,"最后，谈一下在实现 JS 模块化的基础上的发散。随着应用日益复杂，在前端应用开发过程中不仅仅只有 JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题。而且从宏观角度来看，这些文件也都应该看作前端应用中的一个模块，只不过这些模块的种类和用途跟 JavaScript 不同。")],-1),m=s("p",null,"接下来我们先对这个更好的方案或者工具提出一些设想：",-1),g=s("ul",null,[s("li",null,"第一，它需要具备编译代码的能力，也就是将我们开发阶段编写的那些包含新特性的代码转换为能够兼容大多数环境的代码，解决我们所面临的环境兼容问题。"),s("li",null,"第二，能够将散落的模块再打包到一起，这样就解决了浏览器频繁请求模块文件的问题。这里需要注意，只是在开发阶段才需要模块化的文件划分，因为它能够帮我们更好地组织代码，到了实际运行阶段，这种划分就没有必要了。"),s("li",null,"第三，它需要支持不同种类的前端模块类型，也就是说可以将开发过程中涉及的样式、图片、字体等所有资源文件都作为模块使用，这样我们就拥有了一个统一的模块化方案，所有资源文件的加载都可以通过代码控制，与业务代码统一维护，更为合理。")],-1),E=s("p",null,"针对上面第一、第二个设想，我们可以借助 Gulp 之类的构建系统配合一些编译工具和插件去实现，但是对于第三个可以对不同种类资源进行模块化的设想，就很难通过这种方式去解决了，所以就有了我们接下来要介绍的主题：前端模块打包工具。",-1),_=s("h3",{id:"结语",tabindex:"-1"},[o("结语 "),s("a",{class:"header-anchor",href:"#结语","aria-label":'Permalink to "结语"'},"​")],-1),q=s("p",null,"虽然 Webpack 发展到今天，它的功能已经非常强大了，但依然改变不了它是一个模块化解决方案的初衷。你可以看到， Webpack 官方的 Slogan 仍然是：A bundler for javascript and friends（一个 JavaScript 和周边的打包工具）。",-1),f=s("p",null,"从另外一个角度来看，Webpack 从一个“打包工具”，发展成现在开发者眼中对整个前端项目的“构建系统”，表面上似乎只是称呼发生了变化，但是这背后却透露出来一个信号：模块化思想是非常伟大的，伟大到可以帮你“统治”前端整个项目。这也足以见得模块化思想背后还有很多值得我们思考的内容。",-1),b=s("p",null,"总的来说，我们可以把 Webpack 看作现代化前端应用的“管家”，这个“管家”所践行的核心理论就是“模块化”，也就是说  Webpack 以模块化思想为核心，帮助开发者更好的管理整个前端工程。",-1);function j(S,k,v,T,x,I){const a=r("font");return t(),c("div",null,[D,n(a,{color:"red"},{default:l(()=>[o("缺点 "),y]),_:1}),i,n(a,{color:"red"},{default:l(()=>[o("这种命名空间的方式只是解决了命名冲突的问题，但是其它问题依旧存在。")]),_:1}),A,n(a,{color:"red"},{default:l(()=>[o("这种方式带来了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问，这就解决了前面所提到的全局作用域污染和命名冲突的问题。")]),_:1}),C,n(a,{color:"red"},{default:l(()=>[d]),_:1}),u,n(a,{color:"pink"},{default:l(()=>[h]),_:1}),m,n(a,{color:"pink"},{default:l(()=>[g]),_:1}),E,_,q,f,b])}const w=e(F,[["render",j]]);export{M as __pageData,w as default};
